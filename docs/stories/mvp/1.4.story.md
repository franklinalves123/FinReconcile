# Story 1.4 — Prevenção de Duplicatas e Cascade Delete

**Epic:** MVP — Fase 1: Core Funcional
**Status:** Ready
**Estimativa:** 3 pontos (M)
**Agente responsável:** @dev (Dex)

---

## Objetivo

Corrigir dois bugs de integridade de dados críticos:
1. Reimportar a mesma fatura gera registros duplicados no banco
2. Excluir uma fatura NÃO remove as transações vinculadas (dados órfãos)

---

## Escopo

### IN
- Verificar duplicata de fatura antes de processar (por nome + banco + tamanho ou hash)
- Exibir aviso claro ao usuário se fatura já foi importada, com opção de cancelar ou reimportar
- Implementar cascade delete: ao excluir fatura, excluir todas as transactions com aquele `invoice_id`
- Adicionar modal de confirmação customizado (substituir `window.confirm()` na exclusão de faturas)

### OUT
- Não implementar deduplicação de transações individuais (apenas ao nível de fatura)
- Não alterar outras ocorrências de `window.confirm()` (escopo da Story 1.5)

---

## Critérios de Aceite

- [ ] Importar a mesma fatura PDF duas vezes exibe aviso e não cria duplicata sem consentimento explícito
- [ ] O aviso informa nome do arquivo, banco e data de importação anterior
- [ ] Se o usuário confirmar reimport, a fatura anterior é excluída (com suas transactions) e a nova é processada
- [ ] Excluir uma fatura remove TODAS as transactions com `invoice_id` correspondente do Supabase
- [ ] Modal de confirmação de exclusão é um componente React (não `window.confirm()`)
- [ ] Após exclusão, a contagem de transações no Dashboard é atualizada corretamente

---

## Notas Técnicas

### Detecção de duplicata
Estratégia simples: antes de processar o upload, verificar se já existe uma `invoice` com o mesmo `name` E `card_issuer` para o usuário atual.

```typescript
// Em dataService.ts — nova função
async checkDuplicateInvoice(name: string, cardIssuer: string, userId: string): Promise<InvoiceFile | null> {
  const { data } = await supabase
    .from('invoices')
    .select('*')
    .eq('user_id', userId)
    .eq('name', name)
    .eq('card_issuer', cardIssuer)
    .maybeSingle();
  return data;
}
```

### Cascade delete em `dataService.ts`
```typescript
async deleteInvoice(invoiceId: string, userId: string) {
  // 1. Deletar transactions vinculadas
  await supabase.from('transactions')
    .delete()
    .eq('invoice_id', invoiceId)
    .eq('user_id', userId);

  // 2. Deletar a fatura
  const { error } = await supabase.from('invoices')
    .delete()
    .eq('id', invoiceId)
    .eq('user_id', userId);

  if (error) throw error;
}
```

**Alternativa:** Configurar cascade delete no Supabase (FK com `ON DELETE CASCADE`). Preferir solução no código para manter a lógica visível e não depender de configuração de banco.

### Componente de confirmação modal
Criar `components/ui/ConfirmModal.tsx` simples com props: `title`, `message`, `onConfirm`, `onCancel`, `isOpen`.

---

## Riscos

- **Baixo:** A verificação por nome+banco pode falhar se usuário renomear o arquivo PDF antes de fazer upload
- **Médio:** Supabase pode ter restrição de FK que impede delete de invoice sem cascade configurado — verificar e documentar

---

## Testes Sugeridos

1. Importar fatura → reimportar o mesmo arquivo → deve exibir aviso de duplicata
2. Confirmar reimport → verificar que apenas 1 fatura existe e transações não duplicaram
3. Cancelar reimport → verificar que nada mudou no banco
4. Excluir uma fatura → verificar no Supabase Dashboard que as transactions foram removidas
5. Verificar que Dashboard total de gastos diminui após exclusão

---

## File List

| Arquivo | Ação |
|---------|------|
| `services/dataService.ts` | Modificar (cascade delete, checkDuplicate) |
| `App.tsx` | Modificar (verificação antes de processar upload) |
| `components/Invoices.tsx` | Modificar (usar ConfirmModal) |
| `components/ui/ConfirmModal.tsx` | Criar |

---

## Change Log

| Data | Agente | Ação |
|------|--------|------|
| 2026-02-20 | @architect (Brownfield) | Story criada |
